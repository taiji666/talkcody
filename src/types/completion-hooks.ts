// src/types/completion-hooks.ts
/**
 * Completion Hook System
 *
 * Provides a pluggable pipeline for post-execution logic in LLMService.
 * Hooks run after a successful agent loop completion (no tool calls) and can:
 * - Decide whether to stop or continue execution
 * - Modify context for the next iteration
 * - Persist artifacts and state
 *
 * Hook execution order is determined by priority (lower = earlier).
 * Default priorities:
 *   - Stop Hook: 10
 *   - Ralph Loop: 20
 *   - Auto Code Review: 30
 */

import type { AgentLoopState, UIMessage } from './agent';
import type { RalphLoopStopReason } from './ralph-loop';

/**
 * Summary of a tool execution for evaluation purposes
 */
export interface ToolSummary {
  /** Name of the tool that was executed */
  toolName: string;
  /** Unique ID for this tool call */
  toolCallId: string;
  /** For bash tool: the command that was executed */
  command?: string;
  /** Whether the tool execution succeeded */
  success?: boolean;
  /** Tool output (truncated if large) */
  output?: string;
  /** Error message if tool failed */
  error?: string;
}

/**
 * Context passed to completion hooks
 */
export interface CompletionHookContext {
  /** Task ID for this execution */
  taskId: string;
  /** Full text generated by the agent in this iteration */
  fullText: string;
  /** Summaries of tool executions in this iteration */
  toolSummaries: ToolSummary[];
  /** Current state of the agent loop */
  loopState: AgentLoopState;
  /** Ralph iteration counter (separate from agent's internal step counter) */
  iteration: number;
  /** When this Ralph loop started */
  startTime: number;
  /** Original user message/task */
  userMessage?: string;
  /** System prompt used */
  systemPrompt?: string;
}

/**
 * Result returned by a completion hook
 */
export interface CompletionHookResult {
  /** Action to take after this hook */
  action: 'stop' | 'continue' | 'skip';
  /** Stop reason if action is 'stop' */
  stopReason?: RalphLoopStopReason;
  /** Human-readable stop message */
  stopMessage?: string;
  /** Messages to use for next iteration if action is 'continue' */
  nextMessages?: UIMessage[];
}

/**
 * Interface for completion hooks
 *
 * Implement this interface to add custom post-execution logic.
 */
export interface CompletionHook {
  /** Unique name for this hook */
  name: string;
  /** Execution priority (lower = earlier). Recommended: 10, 20, 30... */
  priority: number;
  /** Whether this hook should run for the given context */
  shouldRun: (context: CompletionHookContext) => boolean;
  /** Execute the hook and return result */
  run: (context: CompletionHookContext) => Promise<CompletionHookResult>;
}

/**
 * Configuration for the completion hook pipeline
 */
export interface CompletionHookPipelineConfig {
  /** Maximum time to wait for all hooks to complete */
  timeoutMs?: number;
  /** Whether to stop on first hook that returns 'stop' or 'continue' */
  stopOnFirstAction?: boolean;
  /** Logger for hook execution */
  logger?: {
    debug: (message: string, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
    error: (message: string, ...args: unknown[]) => void;
  };
}
